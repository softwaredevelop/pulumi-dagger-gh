package main

import (
	"ci/cit"
	"ci/lint"
	"ci/util"
	"context"
	"log"
	"os"
	"testing"

	"dagger.io/dagger"
	"github.com/stretchr/testify/require"
)

func TestGoTestAlpine(t *testing.T) {
	t.Parallel()
	ctx := context.Background()

	// c, err := dagger.Connect(ctx, dagger.WithLogOutput(os.Stdout))
	c, err := dagger.Connect(ctx)
	require.NoError(t, err)
	defer c.Close()

	c = c.Pipeline("ci")
	require.NotNil(t, c)

	id, err := c.
		Container().
		From("golang:alpine").
		WithExec([]string{"apk", "update"}).
		WithExec([]string{"apk", "add", "--no-cache", "docker"}).
		WithMountedTemp("/mountedtmp").
		ID(ctx)
	require.NoError(t, err)
	require.NotEmpty(t, id)

	p, err := util.HostDirectoryPath("..")
	require.NoError(t, err)
	require.NotEmpty(t, p)

	mountedDir := "/mountedtmp"
	id, err = util.MountedHostDirectory(c, id, p, mountedDir).
		ID(ctx)
	require.NoError(t, err)
	require.NotEmpty(t, id)

	out, err := c.
		Container(dagger.ContainerOpts{ID: id}).
		WithWorkdir(mountedDir).
		WithExec([]string{"go", "test", "-v", "./ci/lint"}).
		Stdout(ctx)
	require.NoError(t, err)
	log.Println(out)
}

func TestGoTest(t *testing.T) {
	t.Parallel()
	ctx := context.Background()

	c, err := dagger.Connect(ctx, dagger.WithLogOutput(os.Stdout))
	require.NoError(t, err)
	defer c.Close()

	c = c.Pipeline("ci")
	require.NotNil(t, c)

	id, err := c.
		Container().
		From("busybox:glibc").
		WithMountedTemp("/mountedtmp").
		ID(ctx)
	require.NoError(t, err)
	require.NotEmpty(t, id)

	p, err := util.HostDirectoryPath("..")
	require.NoError(t, err)
	require.NotEmpty(t, p)

	mountedDir := "/mountedtmp"
	id, err = util.MountedHostDirectory(c, id, p, mountedDir).
		ID(ctx)
	require.NoError(t, err)
	require.NotEmpty(t, id)

	version := "1.20.2"
	out, err := cit.GoTest(c, id, version).
		Pipeline("gotest").
		WithWorkdir(mountedDir).
		// WithExec([]string{"ls", "-la"}).
		WithExec([]string{"/usr/local/go/bin/go", "test", "-v", "./ci/lint/..."}).
		Stdout(ctx)
	require.NoError(t, err)
	log.Println(out)
}

func TestRevive(t *testing.T) {
	t.Parallel()
	ctx := context.Background()

	c, err := dagger.Connect(ctx, dagger.WithLogOutput(os.Stdout))
	require.NoError(t, err)
	defer c.Close()

	c = c.Pipeline("ci")
	require.NotNil(t, c)

	id, err := c.
		Container().
		From("busybox:uclibc").
		WithMountedTemp("/mountedtmp").
		ID(ctx)
	require.NoError(t, err)
	require.NotEmpty(t, id)

	p, err := util.HostDirectoryPath("..")
	require.NoError(t, err)
	require.NotEmpty(t, p)

	mountedDir := "/mountedtmp"
	id, err = util.MountedHostDirectory(c, id, p, mountedDir).
		ID(ctx)
	require.NoError(t, err)
	require.NotEmpty(t, id)

	out, err := lint.Revive(c, id).
		Pipeline("revive").
		WithWorkdir(mountedDir).
		WithExec([]string{"revive", "./..."}).
		Stdout(ctx)
	require.NoError(t, err)
	log.Println(out)
}

func TestGoLint(t *testing.T) {
	t.Parallel()
	ctx := context.Background()

	c, err := dagger.Connect(ctx, dagger.WithLogOutput(os.Stdout))
	require.NoError(t, err)
	defer c.Close()

	c = c.Pipeline("ci")
	require.NotNil(t, c)

	id, err := c.
		Container().
		From("busybox:uclibc").
		WithMountedTemp("/mountedtmp").
		ID(ctx)
	require.NoError(t, err)
	require.NotEmpty(t, id)

	p, err := util.HostDirectoryPath("..")
	require.NoError(t, err)
	require.NotEmpty(t, p)

	mountedDir := "/mountedtmp"
	id, err = util.MountedHostDirectory(c, id, p, mountedDir).
		ID(ctx)
	require.NoError(t, err)
	require.NotEmpty(t, id)

	out, err := lint.GoLint(c, id).
		WithWorkdir(mountedDir).
		WithExec([]string{"fgt", "golint", "-set_exit_status", "./..."}).
		Stdout(ctx)
	require.NoError(t, err)
	log.Println(out)
}

func TestClientPipeline(t *testing.T) {
	t.Parallel()
	ctx := context.Background()

	c, err := dagger.Connect(ctx, dagger.WithLogOutput(os.Stdout))
	require.NoError(t, err)
	defer c.Close()

	p1 := c.Pipeline("lint")
	require.NotNil(t, p1)

	id, err := p1.
		Container().
		From("busybox:uclibc").
		WithMountedTemp("/mountedtmp").
		ID(ctx)
	require.NoError(t, err)
	require.NotEmpty(t, id)

	p, err := util.HostDirectoryPath("..")
	require.NoError(t, err)
	require.NotEmpty(t, p)

	mountedDir := "/mountedtmp"
	id, err = util.MountedHostDirectory(p1, id, p, mountedDir).
		ID(ctx)
	require.NoError(t, err)
	require.NotEmpty(t, id)

	ec, err := lint.Ec(p1, id).
		Pipeline("ec").
		WithWorkdir(mountedDir).
		WithExec([]string{"editorconfig-checker", "-verbose"}).
		Stdout(ctx)
	require.NoError(t, err)
	require.NotEmpty(t, ec)

	al, err := lint.Al(p1, id).
		Pipeline("actionlint").
		WithWorkdir(mountedDir).
		WithExec([]string{"actionlint", "-pyflakes=", "-verbose", ".github/workflows/dagger.yml"}).
		Stdout(ctx)
	require.NoError(t, err)
	require.Empty(t, al)
}

func TestMountedHostRootDirectory(t *testing.T) {
	t.Parallel()
	ctx := context.Background()

	c, err := dagger.Connect(ctx, dagger.WithLogOutput(os.Stdout))
	require.NoError(t, err)
	defer c.Close()

	container := c.Container().From("busybox:uclibc")
	require.NotNil(t, container)

	p, err := util.HostDirectoryPath("..")
	require.NoError(t, err)
	require.NotEmpty(t, p)
	id, err := container.
		WithMountedDirectory("/mountedtmp", c.Host().Directory(p)).
		ID(ctx)
	require.NoError(t, err)
	require.NotEmpty(t, id)

	mntdir, err := c.
		Container(dagger.ContainerOpts{ID: id}).
		WithExec([]string{"ls", "/mountedtmp"}).
		Stdout(ctx)
	require.NoError(t, err)
	require.NotEmpty(t, mntdir)
}

func TestContainerID(t *testing.T) {
	t.Parallel()
	ctx := context.Background()

	c, err := dagger.Connect(ctx, dagger.WithLogOutput(os.Stdout))
	require.NoError(t, err)
	defer c.Close()

	container := c.Container().From("alpine")
	require.NotNil(t, container)

	id, err := container.ID(ctx)
	require.NoError(t, err)
	require.NotEmpty(t, id)

	releaseName, err := c.Container(dagger.ContainerOpts{ID: id}).
		WithExec([]string{"/bin/sh", "-c", "cat /etc/os-release | awk -F= '/^NAME/ {print $2}' | tr -d '\"'"}).
		Stdout(ctx)
	require.NoError(t, err)
	require.Equal(t, "Alpine Linux\n", releaseName)
}

func TestErrorMessage(t *testing.T) {
	t.Parallel()
	ctx := context.Background()

	c, err := dagger.Connect(ctx, dagger.WithLogOutput(os.Stdout))
	require.NoError(t, err)
	defer c.Close()

	_, err = c.
		Container().
		From("fake.invalid").
		ID(ctx)
	require.Error(t, err)
	require.ErrorContains(t, err, "not exist")
}

func TestConnect(t *testing.T) {
	t.Parallel()
	ctx := context.Background()

	c, err := dagger.Connect(ctx, dagger.WithLogOutput(os.Stdout))
	require.NoError(t, err)
	defer c.Close()
}
